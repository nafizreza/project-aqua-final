/* 
 * ROBOTICS CLUB RECRUITMENT TASK - ENGINE
 * 
 * This file contains the simulation engine, rendering logic, and input handling.
 * PLEASE DO NOT EDIT THIS FILE.
 * 
 * Focus your attention on student_task.js.
 */

// --- SIMULATION CONFIGURAION & STATE ---
const CONFIG = {
    canvasWidth: 400,
    canvasHeight: 400,
    friction: 0.92, 
    worldSize: 2000,
    motorPower: 0.0003, 
    rotationPower: 0.00001,
    ballastRate: 0.1
};

const rover = {
    x: CONFIG.canvasWidth / 2,
    y: CONFIG.canvasHeight / 2,
    z: 50, // Depth
    heading: -Math.PI / 2,
    speed: 0,
    turnSpeed: 0,
    verticalSpeed: 0,
    
    // Hardware State
    motorLeft: 0,   // -1023 to 1023
    motorRight: 0,  // -1023 to 1023
    ballast: 50,    // 0 to 100 (50 is neutral)
    pumpInject: 0,  // 0 to 1023
    pumpEject: 0    // 0 to 1023
};

// Global Inputs for Joysticks (Range -1 to 1)
let joystickLeft = { x: 0, y: 0 };
let joystickRight = { x: 0, y: 0 };

let controlMode = 'buttons';

// --- HARDWARE API (Given to Students) ---
window.leftMotorDriver = function(value) {
    // Clamp between -1023 and 1023
    rover.motorLeft = Math.max(-1023, Math.min(1023, value));
}

window.rightMotorDriver = function(value) {
    rover.motorRight = Math.max(-1023, Math.min(1023, value));
}

window.injectorPump = function(value) {
    rover.pumpInject = Math.max(0, Math.min(1023, value));
}

window.ejectorPump = function(value) {
    rover.pumpEject = Math.max(0, Math.min(1023, value));
}


// --- VISUALIZATION ENGINE ---
const canvasTop = document.getElementById('topView');
const ctxTop = canvasTop.getContext('2d');
const canvasSide = document.getElementById('sideView');
const ctxSide = canvasSide.getContext('2d');

// Generate pseudo-random terrain
const terrain = [];
for (let i = 0; i <= CONFIG.canvasWidth; i+=5) {
    terrain.push({x: i, y: 350 + Math.sin(i * 0.02) * 30 + Math.sin(i * 0.1) * 10});
}

function drawTopView() {
    ctxTop.clearRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);
    
    // Grid
    ctxTop.strokeStyle = 'rgba(0, 180, 216, 0.2)';
    ctxTop.lineWidth = 1;
    const offset = 40;
    
    const panX = rover.x % offset;
    const panY = rover.y % offset;
    
    for (let x = -offset; x < CONFIG.canvasWidth + offset; x += offset) {
        ctxTop.beginPath();
        ctxTop.moveTo(x - panX, 0);
        ctxTop.lineTo(x - panX, CONFIG.canvasHeight);
        ctxTop.stroke();
    }
    for (let y = -offset; y < CONFIG.canvasHeight + offset; y += offset) {
        ctxTop.beginPath();
        ctxTop.moveTo(0, y - panY);
        ctxTop.lineTo(CONFIG.canvasWidth, y - panY);
        ctxTop.stroke();
    }

    // Draw Rover
    ctxTop.save();
    ctxTop.translate(CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2);
    ctxTop.rotate(rover.heading + Math.PI / 2); // Correct offset for Up-pointing sprite
    
    // Body
    ctxTop.fillStyle = '#ffcc00';
    ctxTop.shadowBlur = 10;
    ctxTop.shadowColor = '#ffcc00';
    ctxTop.beginPath();
    ctxTop.moveTo(0, -15);
    ctxTop.lineTo(10, 10);
    ctxTop.lineTo(0, 5);
    ctxTop.lineTo(-10, 10);
    ctxTop.closePath();
    ctxTop.fill();
    
    // Thrusters visualization
    if (Math.abs(rover.motorLeft) > 10) {
        ctxTop.fillStyle = rover.motorLeft > 0 ? '#00ffff' : '#ff0000';
        ctxTop.beginPath();
        ctxTop.arc(-8, 10, 3 + Math.abs(rover.motorLeft)/300, 0, Math.PI * 2);
        ctxTop.fill();
    }
    if (Math.abs(rover.motorRight) > 10) {
        ctxTop.fillStyle = rover.motorRight > 0 ? '#00ffff' : '#ff0000';
        ctxTop.beginPath();
        ctxTop.arc(8, 10, 3 + Math.abs(rover.motorRight)/300, 0, Math.PI * 2);
        ctxTop.fill();
    }

    ctxTop.restore();
    
    // HUD
    ctxTop.fillStyle = 'white';
    ctxTop.font = '12px monospace';
    ctxTop.fillText(`X: ${Math.floor(rover.x)} Y: ${Math.floor(rover.y)}`, 10, 20);
    ctxTop.fillText(`H: ${Math.floor(rover.heading * 180 / Math.PI)%360}`, 10, 35);
    ctxTop.fillText(`L: ${Math.floor(rover.motorLeft)} R: ${Math.floor(rover.motorRight)}`, 10, 50);
}

function drawSideView() {
    ctxSide.clearRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);
    
    // Water Surface
    ctxSide.fillStyle = 'rgba(0, 119, 182, 0.3)';
    ctxSide.fillRect(0, 20, CONFIG.canvasWidth, CONFIG.canvasHeight);
    ctxSide.beginPath();
    ctxSide.moveTo(0, 20);
    ctxSide.lineTo(CONFIG.canvasWidth, 20);
    ctxSide.strokeStyle = '#caf0f8';
    ctxSide.lineWidth = 2;
    ctxSide.stroke();
    
    // Draw Terrain
    ctxSide.fillStyle = '#0f1c2e';
    ctxSide.beginPath();
    ctxSide.moveTo(0, CONFIG.canvasHeight);
    
    // Generate terrain dynamically based on current position to create scrolling effect
    // We'll use rover.x + rover.y (simple travel metric) or just rover.x as the offset
    const offset = rover.x + rover.y; 
    
    for (let i = 0; i <= CONFIG.canvasWidth; i+=5) {
        // Same formula as original terrain gen but with offset
        let h = 350 + Math.sin((i + offset) * 0.02) * 30 + Math.sin((i + offset) * 0.1) * 10;
        ctxSide.lineTo(i, h);
    }
    
    ctxSide.lineTo(CONFIG.canvasWidth, CONFIG.canvasHeight);
    ctxSide.fill();
    
    // Draw Rover (Side Profile)
    ctxSide.save();
    let renderY = rover.z; 
    ctxSide.translate(CONFIG.canvasWidth / 2, renderY + 20); 
    
    ctxSide.fillStyle = '#ffcc00';
    ctxSide.shadowBlur = 10;
    ctxSide.shadowColor = '#ffcc00';
    
    ctxSide.beginPath();
    ctxSide.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2);
    ctxSide.fill();
    
    ctxSide.fillStyle = '#e0e1dd';
    ctxSide.fillRect(-5, -15, 4, 10);
    ctxSide.fillRect(-5, -15, 10, 4);

    // Ballast Indicator
    ctxSide.fillStyle = `rgba(0, 0, 255, ${rover.ballast / 100})`;
    ctxSide.beginPath();
    ctxSide.arc(0, 0, 8, 0, Math.PI * 2);
    ctxSide.fill();

    ctxSide.restore();
    
    // Depth HUD
    ctxSide.fillStyle = 'white';
    ctxSide.font = '12px monospace';
    ctxSide.fillText(`DEPTH: ${Math.floor(rover.z)}m`, 10, 20);
    ctxSide.fillText(`BALLAST: ${Math.floor(rover.ballast)}%`, 10, 35);
}

// --- JOYSTICK UI HANDLER ---
function setupJoystick(baseId, outputObj, isVerticalOnly = false) {
    const base = document.getElementById(baseId);
    if (!base) return;
    const stick = base.querySelector('.joystick-stick');

    // State
    let dragging = false;

    function handleMove(clientX, clientY) {
        if (!dragging) return;
        
        // Recalculate bounds and center dynamically to handle resize/flow changes
        const rect = base.getBoundingClientRect();
        const center = { x: rect.width / 2, y: rect.height / 2 };
        const maxRadius = rect.width / 2 - 40; // 40 is stick radius (80px / 2)

        let dx = clientX - rect.left - center.x;
        let dy = clientY - rect.top - center.y;
        
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > maxRadius) {
            const ratio = maxRadius / distance;
            dx *= ratio;
            dy *= ratio;
        }
        
        if (isVerticalOnly) dx = 0; 

        stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        stick.classList.add('active');

        // Output Range: -1024 to 1024
        // Invert Y so Up is Positive (Standard Control)
        outputObj.x = (dx / maxRadius) * 1024;
        outputObj.y = (dy / maxRadius) * -1024; 
    }

    function stopDrag() {
        dragging = false;
        stick.style.transform = `translate(-50%, -50%)`;
        stick.classList.remove('active');
        outputObj.x = 0;
        outputObj.y = 0;
    }

    base.addEventListener('mousedown', (e) => { dragging = true; handleMove(e.clientX, e.clientY); });
    document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
    document.addEventListener('mouseup', stopDrag);
}

setupJoystick('stick1', joystickLeft);
setupJoystick('stick2', joystickRight, true);

// --- PHYSICS ENGINE ---
function updatePhysics() {
    // 1. Calculate Forces from Motors
    
    // Forward Force = Average of both motors
    // If both are 1024 -> Full forward
    // If Left 1024, Right -1024 -> 0 Forward, just turn
    const forwardThrust = (rover.motorLeft + rover.motorRight) / 2;
    // Differential Steering
    // Left motor pushes Right side (Clockwise)? No, usually left motor is on left side.
    // Left Motor Forward -> Torque to turn Right (Clockwise)
    // Right Motor Forward -> Torque to turn Left (Counter-Clockwise)
    const turnThrust = (rover.motorLeft - rover.motorRight);

    // Apply Acceleration
    rover.speed += forwardThrust * CONFIG.motorPower * 0.1;
    rover.turnSpeed += turnThrust * CONFIG.rotationPower * 0.1;

    // 2. Ballast & Depth
    // Inject -> Increase Ballast -> Sinker
    // Eject -> Decrease Ballast -> Floater
    if (rover.pumpInject > 0) rover.ballast += rover.pumpInject * 0.0005;
    if (rover.pumpEject > 0) rover.ballast -= rover.pumpEject * 0.0005;
    
    // Clamp Ballast
    if (rover.ballast < 0) rover.ballast = 0;
    if (rover.ballast > 100) rover.ballast = 100;

    // Neutral buoyancy is at 50%
    const buoyancyForce = (rover.ballast - 50) * 0.005; 
    rover.verticalSpeed += buoyancyForce;

    // 3. Movement
    rover.x += Math.cos(rover.heading) * rover.speed;
    rover.y += Math.sin(rover.heading) * rover.speed;
    rover.z += rover.verticalSpeed;
    rover.heading += rover.turnSpeed;

    // 4. Friction / Drag
    rover.speed *= CONFIG.friction;
    rover.turnSpeed *= 0.8; // High water resistance on rotation
    rover.verticalSpeed *= 0.95; // Vertical drag

    // Boundaries
    if (rover.z < 0) { rover.z = 0; rover.verticalSpeed = 0; }
    if (rover.z > 300) { rover.z = 300; rover.verticalSpeed = 0; }
}


// --- MAIN LOOP ---
function gameLoop() {
    // Check if student's function exists
    if (controlMode === 'joystick' && typeof handleJoystickControl === 'function') {
        handleJoystickControl();
    }

    updatePhysics();
    drawTopView();
    drawSideView();
    requestAnimationFrame(gameLoop);
}

// --- TOGGLE CONTROL MODE ---
document.getElementById('controlToggle').addEventListener('change', (e) => {
    const btnPanel = document.getElementById('button-controls');
    const joyPanel = document.getElementById('joystick-controls');
    const label = document.getElementById('modeLabel');

    if (e.target.checked) {
        controlMode = 'joystick';
        btnPanel.classList.add('hidden');
        btnPanel.classList.remove('active');
        joyPanel.classList.remove('hidden');
        joyPanel.classList.add('active');
        label.innerText = "Joystick Control";
    } else {
        controlMode = 'buttons';
        joyPanel.classList.add('hidden');
        joyPanel.classList.remove('active');
        btnPanel.classList.remove('hidden');
        btnPanel.classList.add('active');
        label.innerText = "Button Control";
    }
});

// Start the simulation
requestAnimationFrame(gameLoop);
